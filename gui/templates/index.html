<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cenario â€” Meeting Transcription</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg-color: #f4f7f6;
            --text-color: #333;
            --card-bg: #ffffff;
            --card-border: #e0e0e0;
            --primary-color: #005b96;
            --primary-text: #fff;
            --secondary-bg: #f8f9fa;
            --input-bg: #fff;
            --input-border: #ccc;
            --success-color: #4caf50;
            --error-color: #d32f2f;
            --warning-color: #ff9800;
            --info-color: #666;
            --tab-bg: #f1f1f1;
            --tab-hover: #ddd;
            --tab-active-bg: #005b96;
            --tab-active-text: #fff;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --card-bg: #2d2d2d;
            --card-border: #444;
            --primary-color: #4da3ff;
            --primary-text: #fff;
            --secondary-bg: #333;
            --input-bg: #3d3d3d;
            --input-border: #555;
            --success-color: #66bb6a;
            --error-color: #ef5350;
            --warning-color: #ffa726;
            --info-color: #aaa;
            --tab-bg: #333;
            --tab-hover: #444;
            --tab-active-bg: #4da3ff;
            --tab-active-text: #fff;
        }

        /* High Contrast Theme */
        [data-theme="high-contrast"] {
            --bg-color: #fff;
            --text-color: #000;
            --card-bg: #fff;
            --card-border: #000;
            --primary-color: #000080;
            --primary-text: #fff;
            --secondary-bg: #eee;
            --input-bg: #fff;
            --input-border: #000;
            --success-color: #006400;
            --error-color: #b00000;
            --warning-color: #b8860b;
            --info-color: #000;
            --tab-bg: #ddd;
            --tab-hover: #bbb;
            --tab-active-bg: #000080;
            --tab-active-text: #fff;
        }

        /* Solarized Light */
        [data-theme="solarized-light"] {
            --bg-color: #fdf6e3;
            --text-color: #657b83;
            --card-bg: #eee8d5;
            --card-border: #93a1a1;
            --primary-color: #268bd2;
            --primary-text: #fff;
            --secondary-bg: #fdf6e3;
            --input-bg: #fff;
            --input-border: #93a1a1;
            --success-color: #859900;
            --error-color: #dc322f;
            --warning-color: #b58900;
            --info-color: #586e75;
            --tab-bg: #eee8d5;
            --tab-hover: #d3cbb7;
            --tab-active-bg: #268bd2;
            --tab-active-text: #fff;
        }

        /* Solarized Dark */
        [data-theme="solarized-dark"] {
            --bg-color: #002b36;
            --text-color: #839496;
            --card-bg: #073642;
            --card-border: #586e75;
            --primary-color: #268bd2;
            --primary-text: #fff;
            --secondary-bg: #002b36;
            --input-bg: #073642;
            --input-border: #586e75;
            --success-color: #859900;
            --error-color: #dc322f;
            --warning-color: #b58900;
            --info-color: #93a1a1;
            --tab-bg: #073642;
            --tab-hover: #004052;
            --tab-active-bg: #268bd2;
            --tab-active-text: #fff;
        }

        /* Dracula */
        [data-theme="dracula"] {
            --bg-color: #282a36;
            --text-color: #f8f8f2;
            --card-bg: #44475a;
            --card-border: #6272a4;
            --primary-color: #bd93f9;
            --primary-text: #282a36;
            --secondary-bg: #282a36;
            --input-bg: #44475a;
            --input-border: #6272a4;
            --success-color: #50fa7b;
            --error-color: #ff5555;
            --warning-color: #ffb86c;
            --info-color: #8be9fd;
            --tab-bg: #44475a;
            --tab-hover: #6272a4;
            --tab-active-bg: #bd93f9;
            --tab-active-text: #282a36;
        }

        /* Nord */
        [data-theme="nord"] {
            --bg-color: #2e3440;
            --text-color: #d8dee9;
            --card-bg: #3b4252;
            --card-border: #4c566a;
            --primary-color: #88c0d0;
            --primary-text: #2e3440;
            --secondary-bg: #2e3440;
            --input-bg: #3b4252;
            --input-border: #4c566a;
            --success-color: #a3be8c;
            --error-color: #bf616a;
            --warning-color: #ebcb8b;
            --info-color: #81a1c1;
            --tab-bg: #3b4252;
            --tab-hover: #434c5e;
            --tab-active-bg: #88c0d0;
            --tab-active-text: #2e3440;
        }

        /* Monokai */
        [data-theme="monokai"] {
            --bg-color: #272822;
            --text-color: #f8f8f2;
            --card-bg: #3e3d32;
            --card-border: #75715e;
            --primary-color: #66d9ef;
            --primary-text: #272822;
            --secondary-bg: #272822;
            --input-bg: #3e3d32;
            --input-border: #75715e;
            --success-color: #a6e22e;
            --error-color: #f92672;
            --warning-color: #fd971f;
            --info-color: #ae81ff;
            --tab-bg: #3e3d32;
            --tab-hover: #49483e;
            --tab-active-bg: #66d9ef;
            --tab-active-text: #272822;
        }

        /* Gruvbox Light */
        [data-theme="gruvbox-light"] {
            --bg-color: #fbf1c7;
            --text-color: #3c3836;
            --card-bg: #ebdbb2;
            --card-border: #d5c4a1;
            --primary-color: #076678;
            --primary-text: #fbf1c7;
            --secondary-bg: #f9f5d7;
            --input-bg: #fbf1c7;
            --input-border: #d5c4a1;
            --success-color: #79740e;
            --error-color: #9d0006;
            --warning-color: #b57614;
            --info-color: #458588;
            --tab-bg: #ebdbb2;
            --tab-hover: #d5c4a1;
            --tab-active-bg: #076678;
            --tab-active-text: #fbf1c7;
        }

        /* Gruvbox Dark */
        [data-theme="gruvbox-dark"] {
            --bg-color: #282828;
            --text-color: #ebdbb2;
            --card-bg: #3c3836;
            --card-border: #504945;
            --primary-color: #83a598;
            --primary-text: #282828;
            --secondary-bg: #282828;
            --input-bg: #3c3836;
            --input-border: #504945;
            --success-color: #b8bb26;
            --error-color: #fb4934;
            --warning-color: #fabd2f;
            --info-color: #83a598;
            --tab-bg: #3c3836;
            --tab-hover: #504945;
            --tab-active-bg: #83a598;
            --tab-active-text: #282828;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
            max-width: 960px;
            margin: 0 auto;
            padding-bottom: 60px; /* Space for theme selector */
        }
        h1 { color: var(--primary-color); margin-bottom: 20px; }
        h2 { color: var(--primary-text); background: var(--primary-color); padding: 8px 14px; border-radius: 6px 6px 0 0; font-size: 1em; }

        .card {
            background: var(--card-bg);
            border-radius: 6px;
            margin-bottom: 16px;
            border: 1px solid var(--card-border);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .card-body { padding: 14px; }

        label { display: block; margin-bottom: 4px; font-size: 0.9em; color: var(--info-color); }
        select, input[type="number"], input[type="text"], textarea {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--text-color);
            margin-bottom: 10px;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .row { display: flex; gap: 12px; }
        .row > div { flex: 1; }

        .radio-group { display: flex; gap: 16px; margin-bottom: 12px; }
        .radio-group label { display: inline; color: var(--text-color); cursor: pointer; }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
        }
        .btn-start { background: var(--success-color); color: #fff; }
        .btn-stop { background: var(--error-color); color: #fff; }
        .btn-action { background: var(--primary-color); color: #fff; }
        .btn-warn { background: var(--warning-color); color: #fff; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }

        .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

        .output-area {
            background: var(--secondary-bg);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            padding: 10px;
            height: 220px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85em;
            line-height: 1.6;
            white-space: pre-wrap;
            color: var(--text-color);
        }

        .segment { margin-bottom: 4px; }
        .segment .time { color: var(--primary-color); font-weight: bold; }
        .segment .speaker { color: var(--success-color); font-weight: bold; }
        .segment .text { color: var(--text-color); }
        .segment .channel { color: var(--warning-color); font-size: 0.8em; }

        .status {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            display: inline-block;
        }
        .status.recording { background: var(--success-color); color: #fff; animation: pulse 1.5s infinite; }
        .status.idle { background: #999; color: #fff; }
        .status.processing { background: var(--warning-color); color: #fff; animation: pulse 2s infinite; }

        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--card-border);
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }
        .progress-bar .fill {
            height: 100%;
            background: var(--success-color);
            border-radius: 3px;
            transition: width 0.5s ease;
            width: 0;
        }

        .checkbox-group { display: flex; gap: 16px; margin-bottom: 10px; }
        .checkbox-group label { color: var(--text-color); cursor: pointer; display: inline; }

        .hidden { display: none; }

        .warning { color: var(--warning-color); margin: 6px 0; font-size: 0.9em; }
        .error { color: var(--error-color); margin: 6px 0; font-size: 0.9em; }
        .success { color: var(--success-color); margin: 6px 0; font-size: 0.9em; }
        .info { color: var(--info-color); margin: 6px 0; font-size: 0.9em; }

        /* Tooltip container */
        .tooltip {
          position: relative;
          display: inline-block;
        }

        /* Tooltip text */
        .tooltip .tooltiptext {
          visibility: hidden;
          width: 200px;
          background-color: #555;
          color: #fff;
          text-align: center;
          padding: 5px 0;
          border-radius: 6px;

          /* Position the tooltip text */
          position: absolute;
          z-index: 1;
          bottom: 125%;
          left: 50%;
          margin-left: -100px;

          /* Fade in tooltip */
          opacity: 0;
          transition: opacity 0.3s;
        }

        /* Tooltip arrow */
        .tooltip .tooltiptext::after {
          content: "";
          position: absolute;
          top: 100%;
          left: 50%;
          margin-left: -5px;
          border-width: 5px;
          border-style: solid;
          border-color: #555 transparent transparent transparent;
        }

        /* Show the tooltip text when you mouse over the tooltip container */
        .tooltip:hover .tooltiptext {
          visibility: visible;
          opacity: 1;
        }

        /* Tabs */
        .tab {
            overflow: hidden;
            border: 1px solid var(--card-border);
            background-color: var(--tab-bg);
            border-radius: 6px 6px 0 0;
            margin-bottom: -1px;
        }

        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            color: var(--info-color);
            border-radius: 0;
            margin: 0;
        }

        .tab button:hover {
            background-color: var(--tab-hover);
            color: var(--text-color);
        }

        .tab button.active {
            background-color: var(--tab-active-bg);
            color: var(--tab-active-text);
        }

        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid var(--card-border);
            border-top: none;
            background: var(--card-bg);
            border-radius: 0 0 6px 6px;
            margin-bottom: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tabcontent.active {
            display: block;
        }

        /* System warning banner */
        .sys-banner {
            background: #fff3e0;
            border: 1px solid #ff9800;
            border-left: 5px solid #ff9800;
            border-radius: 6px;
            padding: 12px 14px;
            margin-bottom: 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        .sys-banner-icon { font-size: 1.3em; flex-shrink: 0; margin-top: 1px; }
        .sys-banner-body { flex: 1; }
        .sys-banner-body p { font-size: 0.9em; color: #555; margin-bottom: 8px; line-height: 1.5; }
        .sys-banner-body code {
            background: #ffe0b2;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 0.85em;
            color: #333;
        }
        .sys-banner-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 4px; }
        .sys-banner-actions a {
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            text-decoration: none;
            background: #ff9800;
            color: #fff;
        }
        .sys-banner-actions a:hover { background: #e65100; }
        .sys-banner-dismiss {
            background: none;
            border: none;
            font-size: 1.1em;
            color: #999;
            cursor: pointer;
            padding: 0 4px;
            flex-shrink: 0;
            line-height: 1;
        }
        .sys-banner-dismiss:hover { color: #555; }

        /* Theme Selector */
        .theme-selector {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .theme-selector select {
            margin-bottom: 0;
            padding: 4px;
            width: auto;
        }
        .theme-selector label {
            margin-bottom: 0;
            font-size: 0.85em;
        }

        /* Logo */
        .logo {
            height: 52px;
            display: block;
            transition: filter 0.3s;
        }
        [data-theme="dark"] .logo,
        [data-theme="solarized-dark"] .logo,
        [data-theme="dracula"] .logo,
        [data-theme="nord"] .logo,
        [data-theme="monokai"] .logo,
        [data-theme="gruvbox-dark"] .logo {
            filter: invert(1);
        }
    </style>
</head>
<body>

<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
    <img class="logo" src="/Cenaero_logo.svg" alt="Cenaero">
    <button class="btn-action" onclick="checkForUpdates()">Check for Updates</button>
</div>

<!-- System warnings (e.g. Mac missing BlackHole) -->
<div id="systemWarningsBanner"></div>

<!-- Tabs -->
<div class="tab">
  <button class="tablinks active" onclick="openTab(event, 'Recording')">Recording</button>
  <button class="tablinks" onclick="openTab(event, 'PostProcessing')">Post-Processing</button>
  <button class="tablinks" onclick="openTab(event, 'Summarization')">Summarization</button>
</div>

<!-- Recording Tab -->
<div id="Recording" class="tabcontent active">
    <div class="card-body">
        <h3>Meeting Setup</h3>
        <div class="row">
            <div>
                <label for="meetingName">Meeting Name (optional)</label>
                <input type="text" id="meetingName" placeholder="e.g. standup, sprint-review">
            </div>
            <div>
                <label for="outputFolder">Output Folder</label>
                <div style="display:flex; gap:8px;">
                    <input type="text" id="outputFolder" value="recordings" placeholder="recordings" readonly style="flex-grow:1;">
                    <button class="btn-action" onclick="browseFolder('outputFolder')">Browse</button>
                </div>
            </div>
        </div>
        <div class="row">
            <div>
                <label for="language">Language</label>
                <select id="language">
                    <option value="">Auto-detect</option>
                    <option value="en">English</option>
                    <option value="pt">Portuguese</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="it">Italian</option>
                    <option value="nl">Dutch</option>
                    <option value="ru">Russian</option>
                    <option value="zh">Chinese</option>
                    <option value="ja">Japanese</option>
                    <option value="ko">Korean</option>
                    <option value="ar">Arabic</option>
                </select>
            </div>
        </div>

        <div class="row">
            <div>
                <div class="radio-group" style="margin-bottom: 12px;">
                    <label><input type="radio" name="mode" value="stereo" checked onchange="toggleMode()"> Online Meeting</label>
                    <label><input type="radio" name="mode" value="mono" onchange="toggleMode()"> Local Meeting</label>
                </div>
            </div>
        </div>

        <h3>Source Selection</h3>
        <div class="row">
            <div id="monitorGroup">
                <label for="monitor">Monitor (system audio)</label>
                <select id="monitor"><option value="">Loading...</option></select>
            </div>
            <div>
                <label for="mic">Microphone</label>
                <select id="mic"><option value="">Loading...</option></select>
            </div>
        </div>
        <button class="btn-action" onclick="loadSources()" style="margin-bottom: 20px;">Refresh Sources</button>

        <h3>Recording Controls</h3>
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="liveModel">Live Preview Model</label>
                <select id="liveModel" onchange="updateLanguageForModel()">
                    <optgroup label="General">
                        <option value="tiny" selected>tiny</option>
                        <option value="base">base</option>
                        <option value="small">small</option>
                        <option value="medium">medium</option>
                        <option value="large-v3">large-v3</option>
                    </optgroup>
                    <optgroup label="French (bofenghuang)">
                        <option value="bofenghuang/whisper-medium-french">French medium (769M)</option>
                        <option value="bofenghuang/whisper-large-v3-french-distil-dec2">French large-v3 distil (0.8B, fast)</option>
                        <option value="bofenghuang/whisper-large-v3-french">French large-v3 (2B)</option>
                    </optgroup>
                </select>
            </div>
            <div>
                <label for="chunkSize">Chunk Size (seconds)</label>
                <input type="number" id="chunkSize" value="5" min="2" max="30">
            </div>
        </div>
        <div class="controls" style="margin-bottom:12px;">
            <button id="btnStart" class="btn-start" onclick="startRecording()">Start Recording</button>
            <button id="btnStartPreview" class="btn-warn" onclick="startRecording(true)">Preview Only</button>
            <button id="btnStop" class="btn-stop" onclick="stopRecording()" disabled>Stop</button>
            <span id="statusBadge" class="status idle">Idle</span>
        </div>
        <div id="livePreview" class="output-area"></div>

        <div style="margin-top: 10px;">
            <div class="checkbox-group">
                <label><input type="checkbox" value="txt" class="liveExportFmt" checked> TXT</label>
                <label><input type="checkbox" value="json" class="liveExportFmt" checked> JSON</label>
                <label><input type="checkbox" value="srt" class="liveExportFmt" checked> SRT</label>
            </div>
            <button id="btnLiveExport" class="btn-action" onclick="exportLiveFiles()">Export Live Transcript</button>
            <div id="liveExportLinks" style="margin-top:10px;"></div>
        </div>
    </div>
</div>

<!-- Post-Processing Tab -->
<div id="PostProcessing" class="tabcontent">
    <div class="card-body">
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="postOutputFolder">Output Folder</label>
                <div style="display:flex; gap:8px;">
                    <input type="text" id="postOutputFolder" value="recordings" placeholder="recordings" readonly style="flex-grow:1;">
                    <button class="btn-action" onclick="browseFolder('postOutputFolder')">Browse</button>
                </div>
            </div>
            <div>
                <label for="postFolder">Select Meeting Folder</label>
                <select id="postFolder" onchange="loadFilesForFolder()"><option value="">Loading...</option></select>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="postFile">Audio File</label>
                <div style="display:flex; gap:8px;">
                    <select id="postFile" style="flex-grow:1;"><option value="">Select a folder first</option></select>
                    <button class="btn-action" onclick="browseFile('postFile', 'audio')">Browse</button>
                </div>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="postModel">Model</label>
                <select id="postModel" onchange="updateLanguageForModel()">
                    <optgroup label="General">
                        <option value="tiny">tiny</option>
                        <option value="base">base</option>
                        <option value="small">small</option>
                        <option value="medium" selected>medium</option>
                        <option value="large-v3">large-v3</option>
                    </optgroup>
                    <optgroup label="French (bofenghuang)">
                        <option value="bofenghuang/whisper-medium-french">French medium (769M)</option>
                        <option value="bofenghuang/whisper-large-v3-french-distil-dec2">French large-v3 distil (0.8B, fast)</option>
                        <option value="bofenghuang/whisper-large-v3-french">French large-v3 (2B)</option>
                    </optgroup>
                </select>
            </div>
            <div>
                <label for="postComputeType">Compute Type</label>
                <div class="tooltip" style="width:100%">
                    <select id="postComputeType">
                        <option value="float16" selected>float16 (Default)</option>
                        <option value="int8_float16">int8_float16 (Less VRAM)</option>
                        <option value="int8">int8 (Least VRAM)</option>
                    </select>
                    <span class="tooltiptext">float16: Best quality, most VRAM<br>int8_float16: Near-lossless, ~half VRAM<br>int8: Minimal quality loss, least VRAM</span>
                </div>
            </div>
             <div>
                <label for="beamSize">Beam Size</label>
                <input type="number" id="beamSize" value="5" min="1" max="20">
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div style="display:flex;gap:16px;align-items:end;padding-bottom:10px;">
                <label style="margin:0;"><input type="checkbox" id="chkVadFilter"> VAD Filter</label>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div style="display:flex;gap:16px;align-items:end;padding-bottom:10px;">
                <label style="margin:0;"><input type="checkbox" id="chkChunked" onchange="toggleChunked()"> Chunked Transcription</label>
            </div>
            <div id="chunkMinutesGroup" class="hidden">
                <label for="chunkMinutes">Chunk Size (minutes)</label>
                <input type="number" id="chunkMinutes" value="10" min="2" max="60">
            </div>
        </div>
        <div class="row hidden" style="margin-bottom:12px;">
            <div style="display:flex;gap:16px;align-items:end;padding-bottom:10px;">
                <label style="margin:0;color:#777;cursor:not-allowed;"><input type="checkbox" id="chkDiarize" disabled> Diarization (Disabled)</label>
            </div>
        </div>
        <div class="row hidden" style="margin-bottom:12px;">
            <div>
                <label for="stereoMode">Stereo Mode</label>
                <select id="stereoMode">
                    <option value="joint" selected>Joint (Single Output)</option>
                    <option value="separate">Separate Channels</option>
                </select>
            </div>
        </div>
        <div class="controls" style="margin-bottom:8px;">
            <button id="btnPostStart" class="btn-action" onclick="startPostProcess()">Start Post-Processing</button>
            <button id="btnPostStop" class="btn-stop" onclick="stopPostProcess()" disabled>Stop</button>
            <span id="postStatusBadge" class="status idle">Idle</span>
            <span id="postStatusText" class="info"></span>
        </div>
        <div class="progress-bar"><div id="postProgress" class="fill"></div></div>
        <div id="postOutput" class="output-area"></div>
        <div id="postWarnings"></div>

        <div class="hidden">
            <h3 style="margin-top: 20px;">Speaker Naming</h3>
            <div class="row" style="margin-bottom:12px;">
                <div>
                    <label for="speakerFile">Transcription File</label>
                    <select id="speakerFile"><option value="">No transcriptions found</option></select>
                </div>
                <div style="display:flex;align-items:end;padding-bottom:10px;">
                    <button class="btn-action" onclick="loadSpeakers()">Load Speakers</button>
                </div>
            </div>
            <div id="speakerList"></div>
            <div id="speakerActions" class="hidden" style="margin-top:12px;">
                <button class="btn-start" onclick="applySpeakerNames()">Apply Names &amp; Re-export</button>
                <span id="speakerStatus" class="info"></span>
            </div>
        </div>

<!--        <h3 style="margin-top: 20px;">Export</h3>-->
        <div style="margin-top: 10px;">
        <div class="checkbox-group">
            <label><input type="checkbox" value="txt" class="exportFmt" checked> TXT</label>
            <label><input type="checkbox" value="json" class="exportFmt" checked> JSON</label>
            <label><input type="checkbox" value="srt" class="exportFmt" checked> SRT</label>
        </div>
        <button id="btnExport" class="btn-action" onclick="exportFiles()" disabled>Export</button>
        <div id="exportLinks" style="margin-top:10px;"></div>
    </div>
</div>
</div>

<!-- Summarization Tab -->
<div id="Summarization" class="tabcontent">
    <div class="card-body">
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="summaryOutputFolder">Output Folder</label>
                <div style="display:flex; gap:8px;">
                    <input type="text" id="summaryOutputFolder" value="recordings" placeholder="recordings" readonly style="flex-grow:1;">
                    <button class="btn-action" onclick="browseFolder('summaryOutputFolder')">Browse</button>
                </div>
            </div>
            <div>
                <label for="summaryFolder">Select Meeting Folder</label>
                <select id="summaryFolder" onchange="loadTranscriptionsForSummary()"><option value="">Loading...</option></select>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="summaryFile">Transcription File</label>
                <div style="display:flex; gap:8px;">
                    <select id="summaryFile" style="flex-grow:1;"><option value="">Select a folder first</option></select>
                    <button class="btn-action" onclick="browseFile('summaryFile', 'transcription')">Browse</button>
                </div>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
             <div>
                <label for="summaryModel">Model</label>
                <div class="tooltip" style="width:100%">
                    <select id="summaryModel">
                        <option value="Qwen/Qwen2.5-0.5B-Instruct">Qwen 2.5 0.5B (Fast, Low VRAM)</option>
                        <option value="Qwen/Qwen2.5-1.5B-Instruct">Qwen 2.5 1.5B (Balanced)</option>
                        <option value="Qwen/Qwen2.5-3B-Instruct">Qwen 2.5 3B</option>
                        <option value="meta-llama/Llama-3.2-3B-Instruct">Llama 3.2 3B (Good quality)</option>
                        <option value="microsoft/Phi-3.5-mini-instruct" selected>Phi 3.5 Mini 3.8B (Best quality)</option>
                    </select>
                    <span class="tooltiptext">Qwen 0.5B: ~0.5GB, 1.5B: ~1GB, 3B: ~1.7GB<br>Llama 3.2 3B: ~1.8GB<br>Phi 3.5 Mini: ~2.2GB<br>(4-bit quantized)</span>
                </div>
            </div>
            <div>
                <label for="summaryDetail">Detail Level</label>
                <select id="summaryDetail" onchange="updateMaxTokensPlaceholder()">
                    <option value="concise">Concise</option>
                    <option value="detailed" selected>Detailed</option>
                    <option value="comprehensive">Comprehensive</option>
                </select>
            </div>
            <div>
                <label for="summaryMaxTokens">Max Output Tokens</label>
                <div class="tooltip" style="width:100%">
                    <input type="number" id="summaryMaxTokens" placeholder="2048" min="128" max="8192" step="128">
                    <span class="tooltiptext">Max tokens the model can generate.<br>Leave empty to use detail-level default:<br>Concise: 1024, Detailed: 2048, Comprehensive: 4096</span>
                </div>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="summaryQuant">Quantization</label>
                <div class="tooltip" style="width:100%">
                    <select id="summaryQuant">
                        <option value="4" selected>4-bit (Recommended)</option>
                        <option value="8">8-bit (Better quality)</option>
                        <option value="none">None (Full precision)</option>
                    </select>
                    <span class="tooltiptext">4-bit: ~4x less VRAM, minimal quality loss<br>8-bit: ~2x less VRAM, near-lossless<br>None: Full float16, needs most VRAM</span>
                </div>
            </div>
            <div>
                <label for="summaryChunking">Long Text</label>
                <div class="tooltip" style="width:100%">
                    <select id="summaryChunking" onchange="toggleSummaryChunks()">
                        <option value="auto" selected>Auto (chunk if needed)</option>
                        <option value="always">Always chunk</option>
                        <option value="never">Never chunk</option>
                    </select>
                    <span class="tooltiptext">Auto: chunks only when input exceeds safe token limit<br>Always: forces map-reduce chunking<br>Never: attempts to process full text (may OOM)</span>
                </div>
            </div>
            <div id="summaryNumChunksGroup" class="hidden">
                <label for="summaryNumChunks">Number of Chunks</label>
                <input type="number" id="summaryNumChunks" value="2" min="2" max="50">
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div>
                <label for="summaryCustomPrompt">Custom Prompt (Optional)</label>
                <textarea id="summaryCustomPrompt" placeholder="Leave empty for default prompt."></textarea>
            </div>
        </div>
        <div class="row" style="margin-bottom:12px;">
            <div style="display:flex;align-items:end;padding-bottom:10px;gap:10px;">
                <button id="btnSummarize" class="btn-action" onclick="startSummarization()">Summarize</button>
                <button id="btnStopSummarize" class="btn-stop" onclick="stopSummarization()" disabled>Stop</button>
            </div>
        </div>
        <div id="summaryStatus" class="info"></div>
        <div id="summaryOutput" class="output-area" style="height: 200px;"></div>
        <div style="margin-top:10px;">
             <button id="btnExportMd" class="btn-action" onclick="exportMarkdown()" disabled>Export as Markdown</button>
             <span id="exportMdStatus" class="info"></span>
        </div>
    </div>
</div>

<!-- Theme Selector -->
<div class="theme-selector">
    <label for="themeSelect">Theme:</label>
    <select id="themeSelect" onchange="changeTheme(this.value)">
        <option value="light">Light</option>
        <option value="dark">Dark</option>
        <option value="high-contrast">High Contrast</option>
        <option value="solarized-light">Solarized Light</option>
        <option value="solarized-dark">Solarized Dark</option>
        <option value="dracula">Dracula</option>
        <option value="nord">Nord</option>
        <option value="monokai">Monokai</option>
        <option value="gruvbox-light">Gruvbox Light</option>
        <option value="gruvbox-dark">Gruvbox Dark</option>
    </select>
</div>

<script>
    let currentFile = null;
    let liveEventSource = null;
    let postEventSource = null;
    let summaryEventSource = null;
    let postDuration = 0;

    // ---- Theme ----
    function changeTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('cenario_theme', theme);
    }

    // ---- Tabs ----
    function openTab(evt, tabName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
            tabcontent[i].className = tabcontent[i].className.replace(" active", "");
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabName).style.display = "block";
        document.getElementById(tabName).className += " active";
        evt.currentTarget.className += " active";
    }

    // ---- Helpers ----
    function getMode() {
        return document.querySelector('input[name="mode"]:checked').value;
    }

    function toggleMode() {
        document.getElementById('monitorGroup').classList.toggle('hidden', getMode() === 'mono');
    }

    function toggleChunked() {
        const show = document.getElementById('chkChunked').checked;
        document.getElementById('chunkMinutesGroup').classList.toggle('hidden', !show);
    }

    function toggleSummaryChunks() {
        const mode = document.getElementById('summaryChunking').value;
        document.getElementById('summaryNumChunksGroup').classList.toggle('hidden', mode !== 'always');
    }

    function updateMaxTokensPlaceholder() {
        const defaults = { concise: '1024', detailed: '2048', comprehensive: '4096' };
        const detail = document.getElementById('summaryDetail').value;
        document.getElementById('summaryMaxTokens').placeholder = defaults[detail] || '2048';
    }

    function updateLanguageForModel() {
        const liveModel = document.getElementById('liveModel').value;
        const postModel = document.getElementById('postModel').value;
        const langSelect = document.getElementById('language');
        const isFrench = liveModel.includes('french') || postModel.includes('french');
        langSelect.disabled = isFrench;
        if (isFrench) {
            langSelect._savedValue = langSelect.value;
            langSelect.value = 'fr';
        } else if (langSelect._savedValue !== undefined) {
            langSelect.value = langSelect._savedValue;
        }
    }

    function fmtTime(sec) {
        const m = Math.floor(sec / 60);
        const s = Math.floor(sec % 60);
        return String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
    }

    function escapeHtml(text) {
        const d = document.createElement('div');
        d.textContent = text;
        return d.innerHTML;
    }

    function addSegment(container, data) {
        const isAtBottom = (container.scrollHeight - container.scrollTop) <= (container.clientHeight + 50);
        const div = document.createElement('div');
        div.className = 'segment';
        let html = '<span class="time">[' + fmtTime(data.start) + ']</span> ';
        if (data.channel) {
            html += '<span class="channel">[' + escapeHtml(data.channel) + ']</span> ';
        }
        if (data.speaker) {
            html += '<span class="speaker">' + escapeHtml(data.speaker) + ':</span> ';
        }
        html += '<span class="text">' + escapeHtml(data.text) + '</span>';
        div.innerHTML = html;
        container.appendChild(div);
        if (isAtBottom) {
            container.scrollTop = container.scrollHeight;
        }
    }

    // ---- Browse Folder ----
    function browseFolder(targetId) {
        fetch('/api/browse_folder')
            .then(response => response.json())
            .then(data => {
                if (data.path) {
                    document.getElementById(targetId).value = data.path;
                    localStorage.setItem('cenario_' + targetId, data.path);
                    if (targetId === 'outputFolder' || targetId === 'postOutputFolder' || targetId === 'summaryOutputFolder') {
                        loadFolders(targetId);
                    }
                }
            })
            .catch(err => console.error(err));
    }

    // ---- Browse File ----
    function browseFile(targetId, type) {
        fetch('/api/browse_file?type=' + type)
            .then(response => response.json())
            .then(data => {
                if (data.path) {
                    const sel = document.getElementById(targetId);
                    // Check if option exists
                    let exists = false;
                    for (let i = 0; i < sel.options.length; i++) {
                        if (sel.options[i].value === data.path) {
                            sel.selectedIndex = i;
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        const opt = document.createElement('option');
                        opt.value = data.path;
                        opt.textContent = data.name + (data.size_mb ? ' (' + data.size_mb + ' MB)' : '');
                        sel.appendChild(opt);
                        sel.value = data.path;
                    }

                    if (targetId === 'postFile') {
                        currentFile = data.path;
                    }
                }
            })
            .catch(err => console.error(err));
    }

    // ---- Sources ----
    async function loadSources() {
        try {
            const resp = await fetch('/api/sources');
            const data = await resp.json();

            const monitorSel = document.getElementById('monitor');
            const micSel = document.getElementById('mic');

            monitorSel.innerHTML = '';
            data.monitors.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.device_name;
                opt.textContent = s.display_name + (s.state === 'RUNNING' ? ' [ACTIVE]' : '');
                monitorSel.appendChild(opt);
            });
            if (!data.monitors.length) monitorSel.innerHTML = '<option value="">No monitors found</option>';

            micSel.innerHTML = '';
            data.inputs.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.device_name;
                opt.textContent = s.display_name + (s.state === 'RUNNING' ? ' [ACTIVE]' : '');
                micSel.appendChild(opt);
            });
            if (!data.inputs.length) micSel.innerHTML = '<option value="">No inputs found</option>';

            // Restore previous selection if available
            const savedMonitor = localStorage.getItem('cenario_last_monitor');
            if (savedMonitor) {
                // Check if option exists
                if ([...monitorSel.options].some(o => o.value === savedMonitor)) {
                    monitorSel.value = savedMonitor;
                }
            }
            const savedMic = localStorage.getItem('cenario_last_mic');
            if (savedMic) {
                if ([...micSel.options].some(o => o.value === savedMic)) {
                    micSel.value = savedMic;
                }
            }

        } catch (e) {
            console.error('Failed to load sources:', e);
        }
    }

    async function loadFolders(sourceId = 'outputFolder') {
        try {
            let outputFolder = 'recordings';
            if (sourceId) {
                outputFolder = document.getElementById(sourceId).value || 'recordings';
            }

            const resp = await fetch('/api/folders?base=' + encodeURIComponent(outputFolder));
            const folders = await resp.json();

            let targetSel;
            if (sourceId === 'postOutputFolder') {
                targetSel = document.getElementById('postFolder');
            } else if (sourceId === 'summaryOutputFolder') {
                targetSel = document.getElementById('summaryFolder');
            } else {
                // Default behavior (legacy or recording tab) - update both if they use default
                // But now we have separate inputs, so we should probably update based on which tab we are in or update all?
                // For simplicity, let's update the dropdowns corresponding to the input
                // If called from loadFolders() without args, we might need to check all inputs
                return;
            }

            const html = '<option value="">Select a folder...</option>';
            targetSel.innerHTML = html;

            folders.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.path;
                opt.textContent = f.name;
                targetSel.appendChild(opt);
            });
        } catch (e) {
            console.error('Failed to load folders:', e);
        }
    }

    // Wrapper to load all folders on init
    async function loadAllFolders() {
        const inputs = ['outputFolder', 'postOutputFolder', 'summaryOutputFolder'];
        for (const id of inputs) {
             try {
                const outputFolder = document.getElementById(id).value || 'recordings';
                const resp = await fetch('/api/folders?base=' + encodeURIComponent(outputFolder));
                const folders = await resp.json();

                let targetSel = null;
                if (id === 'postOutputFolder') targetSel = document.getElementById('postFolder');
                if (id === 'summaryOutputFolder') targetSel = document.getElementById('summaryFolder');

                if (targetSel) {
                    const html = '<option value="">Select a folder...</option>';
                    targetSel.innerHTML = html;
                    folders.forEach(f => {
                        const opt = document.createElement('option');
                        opt.value = f.path;
                        opt.textContent = f.name;
                        targetSel.appendChild(opt);
                    });
                }
             } catch (e) {
                 console.error(`Failed to load folders for ${id}:`, e);
             }
        }
    }

    async function loadFilesForFolder() {
        const folder = document.getElementById('postFolder').value;
        if (!folder) return;

        try {
            // Load transcriptions for speaker naming
            loadTranscriptions(folder);

            const resp = await fetch('/api/folder_files?folder=' + encodeURIComponent(folder));
            const files = await resp.json();

            const sel = document.getElementById('postFile');
            sel.innerHTML = '';

            if (!files.length) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No WAV files found';
                sel.appendChild(opt);
                currentFile = null;
                return;
            }

            files.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.path;
                opt.textContent = f.name + ' (' + f.size_mb + ' MB)';
                sel.appendChild(opt);
            });

            currentFile = files[0].path;

        } catch (e) {
            console.error(e);
        }
    }

    async function loadTranscriptionsForSummary() {
        const folder = document.getElementById('summaryFolder').value;
        if (!folder) return;

        try {
            const resp = await fetch('/api/folder_transcriptions?folder=' + encodeURIComponent(folder));
            const files = await resp.json();

            const sel = document.getElementById('summaryFile');
            sel.innerHTML = '';

            if (!files.length) {
                sel.innerHTML = '<option value="">No transcriptions found</option>';
                return;
            }

            files.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.path;
                opt.textContent = f.name + ' (' + f.size_kb + ' KB)';
                sel.appendChild(opt);
            });
        } catch (e) {
            console.error(e);
        }
    }

    // ---- Recording ----
    async function startRecording(previewOnly = false) {
        const mode = getMode();
        const monitor = document.getElementById('monitor').value;
        const mic = document.getElementById('mic').value;
        const liveModel = document.getElementById('liveModel').value;
        const chunk = parseInt(document.getElementById('chunkSize').value) || 5;
        const meetingName = document.getElementById('meetingName').value;
        const outputFolder = document.getElementById('outputFolder').value;
        const language = document.getElementById('language').value;

        // Save selection
        if (monitor) localStorage.setItem('cenario_last_monitor', monitor);
        if (mic) localStorage.setItem('cenario_last_mic', mic);

        const body = {
            mode, mic, live_model: liveModel, chunk,
            meeting_name: meetingName, output_folder: outputFolder,
            preview_only: previewOnly, language,
        };
        if (mode === 'stereo') body.monitor = monitor;

        try {
            const resp = await fetch('/api/record/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await resp.json();

            if (!resp.ok) {
                alert(data.error || 'Failed to start recording');
                return;
            }

            currentFile = data.file;
            document.getElementById('btnStart').disabled = true;
            document.getElementById('btnStartPreview').disabled = true;
            document.getElementById('btnStop').disabled = false;

            const badge = document.getElementById('statusBadge');
            badge.textContent = previewOnly ? 'Preview' : 'Recording';
            badge.className = 'status recording';

            document.getElementById('livePreview').innerHTML = '';
            startLiveSSE();

        } catch (e) {
            alert('Error: ' + e.message);
        }
    }

    function startLiveSSE() {
        if (liveEventSource) liveEventSource.close();
        liveEventSource = new EventSource('/api/live');

        liveEventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.done) {
                liveEventSource.close();
                liveEventSource = null;
                return;
            }
            addSegment(document.getElementById('livePreview'), data);
        };

        liveEventSource.onerror = function() {
            liveEventSource.close();
            liveEventSource = null;
        };
    }

    async function stopRecording() {
        try {
            const resp = await fetch('/api/record/stop', { method: 'POST' });
            const data = await resp.json();

            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnStartPreview').disabled = false;
            document.getElementById('btnStop').disabled = true;

            const badge = document.getElementById('statusBadge');
            badge.textContent = 'Idle';
            badge.className = 'status idle';

            if (liveEventSource) { liveEventSource.close(); liveEventSource = null; }

            if (data.preview_only) {
                currentFile = null;
            } else {
                currentFile = data.file;
                loadAllFolders(); // Refresh folders list
            }

        } catch (e) {
            alert('Error: ' + e.message);
        }
    }

    async function exportLiveFiles() {
        const checkboxes = document.querySelectorAll('.liveExportFmt:checked');
        const formats = Array.from(checkboxes).map(cb => cb.value);

        if (!formats.length) {
            alert('Select at least one export format');
            return;
        }

        const linksDiv = document.getElementById('liveExportLinks');
        linksDiv.innerHTML = '<span class="info">Exporting...</span>';

        try {
            const resp = await fetch('/api/record/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ formats })
            });
            const data = await resp.json();

            if (!resp.ok) {
                linksDiv.innerHTML = '<span class="error">' + escapeHtml(data.error) + '</span>';
                return;
            }

            linksDiv.innerHTML = '<div class="success"><strong>Exported:</strong><br>' +
                data.files.map(f => escapeHtml(f)).join('<br>') + '</div>';

        } catch (e) {
            linksDiv.innerHTML = '<span class="error">Error: ' + escapeHtml(e.message) + '</span>';
        }
    }

    // ---- Post-Processing ----
    async function startPostProcess() {
        const fileSel = document.getElementById('postFile');
        const file = fileSel.value;
        if (!file) {
            alert('Select an audio file first');
            return;
        }

        const model = document.getElementById('postModel').value;
        const computeType = document.getElementById('postComputeType').value;
        const diarize = document.getElementById('chkDiarize').checked;
        const language = document.getElementById('language').value;
        const stereoMode = document.getElementById('stereoMode').value;

        document.getElementById('postOutput').innerHTML = '';
        document.getElementById('postWarnings').innerHTML = '';
        document.getElementById('postProgress').style.width = '0%';
        document.getElementById('btnExport').disabled = true;

        const badge = document.getElementById('postStatusBadge');
        badge.textContent = 'Processing';
        badge.className = 'status processing';
        document.getElementById('postStatusText').textContent = 'Starting...';
        document.getElementById('btnPostStart').disabled = true;
        document.getElementById('btnPostStop').disabled = false;

        try {
            const resp = await fetch('/api/postprocess/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    file, model, diarize, language,
                    compute_type: computeType,
                    beam_size: parseInt(document.getElementById('beamSize').value) || 5,
                    vad_filter: document.getElementById('chkVadFilter').checked,
                    stereo_mode: stereoMode,
                    chunk_minutes: document.getElementById('chkChunked').checked
                        ? (parseInt(document.getElementById('chunkMinutes').value) || 10) : 0
                })
            });
            const data = await resp.json();

            if (!resp.ok) {
                badge.textContent = 'Error';
                badge.className = 'status idle';
                document.getElementById('postStatusText').textContent = data.error;
                document.getElementById('btnPostStart').disabled = false;
                document.getElementById('btnPostStop').disabled = true;
                return;
            }

            postDuration = data.duration || 0;
            currentFile = file;
            startPostSSE();

        } catch (e) {
            badge.textContent = 'Error';
            badge.className = 'status idle';
            document.getElementById('postStatusText').textContent = e.message;
            document.getElementById('btnPostStart').disabled = false;
            document.getElementById('btnPostStop').disabled = true;
        }
    }

    async function stopPostProcess() {
        const btnStop = document.getElementById('btnPostStop');
        btnStop.disabled = true;
        try {
            const resp = await fetch('/api/postprocess/stop', { method: 'POST' });
            const data = await resp.json();
            if (data.error) {
                alert('Error stopping: ' + data.error);
            }
        } catch (e) {
            alert('Error stopping: ' + e.message);
        }
    }

    function startPostSSE() {
        if (postEventSource) postEventSource.close();
        postEventSource = new EventSource('/api/postprocess/stream');

        postEventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            handlePostEvent(data);
        };

        postEventSource.onerror = function() {
            postEventSource.close();
            postEventSource = null;
        };
    }

    function handlePostEvent(data) {
        const statusText = document.getElementById('postStatusText');
        const badge = document.getElementById('postStatusBadge');
        const output = document.getElementById('postOutput');
        const progressBar = document.getElementById('postProgress');

        if (data.type === 'segment') {
            addSegment(output, data);
            // Update progress from segment end time
            if (postDuration > 0 && data.end) {
                const pct = Math.min(100, (data.end / postDuration) * 100);
                progressBar.style.width = pct + '%';
            }
        } else if (data.type === 'chunk_progress') {
            statusText.textContent = data.label || ('Transcribing chunk ' + data.chunk + '/' + data.total);
        } else if (data.type === 'diarize_progress') {
            if (data.total > 0) {
                const pct = Math.min(100, (data.completed / data.total) * 100);
                progressBar.style.width = pct + '%';
                statusText.textContent = 'Diarization: ' + data.step + ' (' + Math.round(pct) + '%)';
            }
        } else if (data.type === 'status') {
            if (data.status === 'transcribing') {
                statusText.textContent = 'Transcribing' + (data.detail ? ': ' + data.detail : '...');
            } else if (data.status === 'diarizing') {
                statusText.textContent = 'Identifying speakers (diarization)...';
                progressBar.style.width = '0%';
                progressBar.style.background = '#ff9800';
            } else if (data.status === 'transcription_done') {
                statusText.textContent = 'Transcription complete. Intermediate files saved.';
            } else if (data.status === 'done') {
                statusText.textContent = 'Done!';
                badge.textContent = 'Done';
                badge.className = 'status idle';
                progressBar.style.width = '100%';
                progressBar.style.background = '#4caf50';
                document.getElementById('btnPostStart').disabled = false;
                document.getElementById('btnPostStop').disabled = true;
                document.getElementById('btnExport').disabled = false;

                // Refresh transcriptions list
                const folder = document.getElementById('postFolder').value;
                if (folder) loadTranscriptions(folder);

                if (postEventSource) { postEventSource.close(); postEventSource = null; }
            } else if (data.status === 'error') {
                badge.textContent = 'Error';
                badge.className = 'status idle';
                document.getElementById('btnPostStart').disabled = false;
                document.getElementById('btnPostStop').disabled = true;

                if (postEventSource) { postEventSource.close(); postEventSource = null; }
            }
        } else if (data.type === 'transcription_saved') {
            const w = document.getElementById('postWarnings');
            w.innerHTML += '<div class="success">Intermediate transcription saved: ' +
                data.files.map(f => escapeHtml(f)).join(', ') + '</div>';
        } else if (data.type === 'warning') {
            const w = document.getElementById('postWarnings');
            w.innerHTML += '<div class="warning">' + escapeHtml(data.message) + '</div>';
            statusText.textContent = 'Completed with warnings';
        } else if (data.type === 'error') {
            statusText.textContent = 'Error: ' + data.message;
            badge.textContent = 'Error';
            badge.className = 'status idle';
            document.getElementById('btnPostStart').disabled = false;
            document.getElementById('btnPostStop').disabled = true;
            document.getElementById('btnExport').disabled = false; // Allow export even on error
            const w = document.getElementById('postWarnings');
            w.innerHTML += '<div class="error">' + escapeHtml(data.message) + '</div>';

            if (postEventSource) { postEventSource.close(); postEventSource = null; }
        }
    }

    // ---- Export ----
    async function exportFiles() {
        const fileSel = document.getElementById('postFile');
        const file = fileSel.value || currentFile;
        if (!file) return;

        const checkboxes = document.querySelectorAll('.exportFmt:checked');
        const formats = Array.from(checkboxes).map(cb => cb.value);

        if (!formats.length) {
            alert('Select at least one export format');
            return;
        }

        const linksDiv = document.getElementById('exportLinks');
        linksDiv.innerHTML = '<span class="info">Exporting...</span>';

        try {
            let allFiles = [];
            if (formats.length === 3) {
                const resp = await fetch('/api/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file, format: 'all' })
                });
                const data = await resp.json();
                if (!resp.ok) { linksDiv.innerHTML = '<span class="error">' + escapeHtml(data.error) + '</span>'; return; }
                allFiles = data.files || [];
            } else {
                for (const f of formats) {
                    const resp = await fetch('/api/export', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file, format: f })
                    });
                    const data = await resp.json();
                    if (resp.ok) allFiles.push(...(data.files || []));
                }
            }

            linksDiv.innerHTML = '<div class="success"><strong>Exported:</strong><br>' +
                allFiles.map(f => escapeHtml(f)).join('<br>') + '</div>';

        } catch (e) {
            linksDiv.innerHTML = '<span class="error">Error: ' + escapeHtml(e.message) + '</span>';
        }
    }

    // ---- Speaker Naming ----
    async function loadTranscriptions(folder = null) {
        try {
            if (!folder) {
                folder = document.getElementById('postFolder').value;
            }
            if (!folder) return;

            const resp = await fetch('/api/folder_transcriptions?folder=' + encodeURIComponent(folder));
            const files = await resp.json();

            // Populate Speaker Naming dropdown
            const speakerSel = document.getElementById('speakerFile');
            speakerSel.innerHTML = '';

            if (!files.length) {
                speakerSel.innerHTML = '<option value="">No transcriptions found</option>';
                return;
            }

            files.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.path;
                opt.textContent = f.name + ' (' + f.size_kb + ' KB)';
                speakerSel.appendChild(opt);
            });
        } catch (e) {
            console.error('Failed to load transcriptions:', e);
        }
    }

    async function loadSpeakers() {
        const file = document.getElementById('speakerFile').value;
        if (!file) {
            alert('Select a transcription file first');
            return;
        }

        const listDiv = document.getElementById('speakerList');
        const actionsDiv = document.getElementById('speakerActions');
        listDiv.innerHTML = '<span class="info">Loading...</span>';
        actionsDiv.classList.add('hidden');
        document.getElementById('speakerStatus').textContent = '';

        try {
            const resp = await fetch('/api/speakers/load', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file })
            });
            const data = await resp.json();

            if (!resp.ok) {
                listDiv.innerHTML = '<span class="error">' + escapeHtml(data.error) + '</span>';
                return;
            }

            if (!data.speakers.length) {
                listDiv.innerHTML = '<span class="info">No speaker labels found in this transcription.</span>';
                return;
            }

            let html = '<table style="width:100%;border-collapse:collapse;">';
            html += '<tr style="border-bottom:1px solid #0f3460;"><th style="text-align:left;padding:6px;color:#aaa;">Speaker Label</th><th style="text-align:left;padding:6px;color:#aaa;">Sample Text</th><th style="text-align:left;padding:6px;color:#aaa;">Name</th></tr>';
            data.speakers.forEach(spk => {
                const samples = spk.samples.map(s => escapeHtml(s)).join('<br>');
                html += '<tr style="border-bottom:1px solid #0f3460;">';
                html += '<td style="padding:6px;color:#e94560;white-space:nowrap;vertical-align:top;">' + escapeHtml(spk.label) + '</td>';
                html += '<td style="padding:6px;font-size:0.85em;color:#aaa;vertical-align:top;">' + samples + '</td>';
                html += '<td style="padding:6px;vertical-align:top;"><input type="text" class="speaker-name" data-label="' + escapeHtml(spk.label) + '" placeholder="' + escapeHtml(spk.label) + '" style="margin:0;width:150px;"></td>';
                html += '</tr>';
            });
            html += '</table>';
            listDiv.innerHTML = html;
            actionsDiv.classList.remove('hidden');

        } catch (e) {
            listDiv.innerHTML = '<span class="error">Error: ' + escapeHtml(e.message) + '</span>';
        }
    }

    async function applySpeakerNames() {
        const file = document.getElementById('speakerFile').value;
        if (!file) return;

        const inputs = document.querySelectorAll('.speaker-name');
        const mapping = {};
        inputs.forEach(inp => {
            const label = inp.dataset.label;
            const name = inp.value.trim();
            if (name) mapping[label] = name;
        });

        if (!Object.keys(mapping).length) {
            alert('Enter at least one speaker name');
            return;
        }

        const statusEl = document.getElementById('speakerStatus');
        statusEl.textContent = 'Applying...';

        try {
            const resp = await fetch('/api/speakers/rename', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file, mapping })
            });
            const data = await resp.json();

            if (!resp.ok) {
                statusEl.textContent = '';
                alert(data.error);
                return;
            }

            statusEl.innerHTML = '<span class="success">Updated! Files: ' +
                data.files.map(f => escapeHtml(f.split('/').pop())).join(', ') + '</span>';

            // Refresh transcriptions list
            const folder = document.getElementById('postFolder').value;
            if (folder) loadTranscriptions(folder);

        } catch (e) {
            statusEl.textContent = 'Error: ' + e.message;
        }
    }

    // ---- Summarization ----
    let summaryFinalResult = '';  // Clean final result (no chunk progress noise)

    async function startSummarization() {
        const file = document.getElementById('summaryFile').value;
        if (!file) {
            alert('Select a transcription file first');
            return;
        }

        const model = document.getElementById('summaryModel').value;
        const detailLevel = document.getElementById('summaryDetail').value;
        const quantization = document.getElementById('summaryQuant').value;
        const chunking = document.getElementById('summaryChunking').value;
        const numChunks = parseInt(document.getElementById('summaryNumChunks').value) || 2;
        const maxTokensRaw = document.getElementById('summaryMaxTokens').value;
        const maxTokens = maxTokensRaw ? parseInt(maxTokensRaw) : null;
        const customPrompt = document.getElementById('summaryCustomPrompt').value;

        const statusDiv = document.getElementById('summaryStatus');
        const outputDiv = document.getElementById('summaryOutput');
        const btn = document.getElementById('btnSummarize');
        const btnStop = document.getElementById('btnStopSummarize');
        const btnExport = document.getElementById('btnExportMd');

        statusDiv.innerHTML = '<span class="status processing">Summarizing...</span>';
        outputDiv.innerHTML = '';
        summaryFinalResult = '';
        btn.disabled = true;
        btnStop.disabled = false;
        btnExport.disabled = true;
        document.getElementById('exportMdStatus').textContent = '';

        try {
            const resp = await fetch('/api/summarize/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file, model, detail_level: detailLevel, quantization, chunking, num_chunks: numChunks, max_new_tokens: maxTokens, custom_prompt: customPrompt })
            });
            const data = await resp.json();

            if (!resp.ok) {
                statusDiv.innerHTML = '<span class="error">' + escapeHtml(data.error) + '</span>';
                btn.disabled = false;
                btnStop.disabled = true;
                return;
            }

            // Start SSE stream
            if (summaryEventSource) summaryEventSource.close();
            summaryEventSource = new EventSource('/api/summarize/stream');

            summaryEventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.text) {
                    const isAtBottom = (outputDiv.scrollHeight - outputDiv.scrollTop) <= (outputDiv.clientHeight + 50);
                    outputDiv.textContent += data.text;
                    if (isAtBottom) {
                        outputDiv.scrollTop = outputDiv.scrollHeight;
                    }
                }
                if (data.done) {
                    summaryEventSource.close();
                    summaryEventSource = null;
                    summaryFinalResult = data.result || '';
                    statusDiv.innerHTML = '<span class="success">Done!</span>';
                    btn.disabled = false;
                    btnStop.disabled = true;
                    btnExport.disabled = false;
                }
                if (data.error) {
                    summaryEventSource.close();
                    summaryEventSource = null;
                    statusDiv.innerHTML = '<span class="error">Error: ' + escapeHtml(data.error) + '</span>';
                    btn.disabled = false;
                    btnStop.disabled = true;
                    btnExport.disabled = false; // Allow export even on error
                }
            };

            summaryEventSource.onerror = function() {
                summaryEventSource.close();
                summaryEventSource = null;
                // If we lost connection but didn't get an explicit error, we might be done or failed silently
                // We can check status one last time or just leave it
            };

        } catch (e) {
            statusDiv.innerHTML = '<span class="error">Error: ' + escapeHtml(e.message) + '</span>';
            btn.disabled = false;
            btnStop.disabled = true;
        }
    }

    async function stopSummarization() {
        const btnStop = document.getElementById('btnStopSummarize');
        btnStop.disabled = true;
        try {
            const resp = await fetch('/api/summarize/stop', { method: 'POST' });
            const data = await resp.json();
            if (data.error) {
                alert('Error stopping: ' + data.error);
            }
        } catch (e) {
            alert('Error stopping: ' + e.message);
        }
    }

    async function exportMarkdown() {
        const text = summaryFinalResult || document.getElementById('summaryOutput').textContent;
        const file = document.getElementById('summaryFile').value;
        const statusEl = document.getElementById('exportMdStatus');

        if (!text) return;

        try {
            const resp = await fetch('/api/summarize/export_markdown', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text, file })
            });
            const data = await resp.json();

            if (resp.ok) {
                const files = data.files || [data.file];
                statusEl.innerHTML = '<span class="success">Saved to:<br>' + files.map(f => escapeHtml(f)).join('<br>') + '</span>';
            } else {
                statusEl.innerHTML = '<span class="error">' + escapeHtml(data.error) + '</span>';
            }
        } catch (e) {
            statusEl.innerHTML = '<span class="error">' + escapeHtml(e.message) + '</span>';
        }
    }

    // ---- Check for in-progress post-processing on page load ----
    async function checkPostStatus() {
        try {
            const resp = await fetch('/api/postprocess/status');
            const data = await resp.json();
            if (data.status === 'transcribing' || data.status === 'diarizing') {
                // Reconnect to running post-processing
                postDuration = data.duration || 0;
                if (data.file) {
                    const sel = document.getElementById('postFile');
                    // Ensure file is in dropdown
                    let found = false;
                    for (const opt of sel.options) {
                        if (opt.value === data.file) { found = true; sel.value = data.file; break; }
                    }
                    if (!found) {
                        const opt = document.createElement('option');
                        opt.value = data.file;
                        opt.textContent = data.file.split('/').pop();
                        sel.appendChild(opt);
                        sel.value = data.file;
                    }
                    currentFile = data.file;
                }

                const badge = document.getElementById('postStatusBadge');
                badge.textContent = 'Processing';
                badge.className = 'status processing';
                document.getElementById('postStatusText').textContent = 'Reconnecting...';
                document.getElementById('btnPostStart').disabled = true;
                document.getElementById('btnPostStop').disabled = false;

                startPostSSE();
            } else if (data.status === 'done' && data.has_result) {
                document.getElementById('btnExport').disabled = false;
                document.getElementById('postStatusText').textContent = 'Previous result available for export.';
                if (data.file) currentFile = data.file;
            }
        } catch (e) {
            // Server not running or no previous state
        }
    }

    // ---- Updates ----
    async function checkForUpdates() {
        try {
            const resp = await fetch('/api/update/check');
            const data = await resp.json();

            if (data.error) {
                alert('Error checking for updates: ' + data.error);
                return;
            }

            if (!data.update_available) {
                alert('You are already on the latest version (' + data.current_version + ').');
                return;
            }

            const msg = 'New version available: ' + data.latest_version + ' (current: ' + data.current_version + ')\n\n' +
                        'Release Notes:\n' + data.release_notes + '\n\n' +
                        'Do you want to update now?';

            if (confirm(msg)) {
                // Perform update
                const performResp = await fetch('/api/update/perform', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: data.download_url, version: data.latest_version })
                });
                const performData = await performResp.json();

                if (performData.status === 'success') {
                    alert('Update successful! The application is restarting...');
                    // Reload page after a delay to allow server restart
                    setTimeout(() => location.reload(), 3000);
                } else {
                    alert('Update failed: ' + (performData.error || 'Unknown error'));
                }
            }
        } catch (e) {
            alert('Error: ' + e.message);
        }
    }

    // ---- Persistence ----
    const persistIds = [
        'language',
        'liveModel',
        'chunkSize',
        'postModel',
        'postComputeType',
        'beamSize',
        'chunkMinutes',
        'summaryModel',
        'summaryDetail',
        'summaryQuant',
        'summaryChunking',
        'summaryNumChunks'
    ];

    function initPersistence() {
        persistIds.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;

            // Load
            const saved = localStorage.getItem('cenario_' + id);
            if (saved !== null) {
                el.value = saved;
            }

            // Save on change
            el.addEventListener('change', () => {
                localStorage.setItem('cenario_' + id, el.value);
            });
        });

        // Checkbox persistence (uses .checked instead of .value)
        ['chkChunked', 'chkVadFilter'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            const saved = localStorage.getItem('cenario_' + id);
            if (saved !== null) {
                el.checked = saved === 'true';
            }
            el.addEventListener('change', () => {
                localStorage.setItem('cenario_' + id, el.checked);
            });
        });

        // Restore dependent visibility
        toggleChunked();
        toggleSummaryChunks();
    }

    // ---- System warnings ----
    async function checkSystemWarnings() {
        try {
            const res = await fetch('/api/system_warnings');
            const warnings = await res.json();
            const banner = document.getElementById('systemWarningsBanner');
            banner.innerHTML = '';
            warnings.forEach(w => {
                const el = document.createElement('div');
                el.className = 'sys-banner';
                el.id = 'syswarn-' + w.id;
                el.innerHTML = `
                    <span class="sys-banner-icon">&#9888;</span>
                    <div class="sys-banner-body">
                        <p>${w.message}</p>
                        ${w.brew ? `<p>Install with Homebrew: <code>${w.brew}</code></p>` : ''}
                        <div class="sys-banner-actions">
                            <a href="${w.link}" target="_blank" rel="noopener">${w.link_text}</a>
                            <button class="btn-action" style="font-size:0.85em;padding:5px 12px;"
                                onclick="checkSystemWarnings()">Check again</button>
                        </div>
                    </div>
                    <button class="sys-banner-dismiss" title="Dismiss"
                        onclick="document.getElementById('syswarn-${w.id}').remove()">&#10005;</button>`;
                banner.appendChild(el);
            });
        } catch (e) {
            // Non-critical â€” silently ignore if endpoint unreachable
        }
    }

    // ---- Init ----
    loadSources();
    loadAllFolders();
    checkPostStatus();
    initPersistence();
    updateLanguageForModel();
    checkSystemWarnings();
    updateMaxTokensPlaceholder();

    // Load persisted folder
    const savedFolder = localStorage.getItem('cenario_output_folder');
    if (savedFolder) {
        document.getElementById('outputFolder').value = savedFolder;
    }
    const savedPostFolder = localStorage.getItem('cenario_postOutputFolder');
    if (savedPostFolder) {
        document.getElementById('postOutputFolder').value = savedPostFolder;
    }
    const savedSummaryFolder = localStorage.getItem('cenario_summaryOutputFolder');
    if (savedSummaryFolder) {
        document.getElementById('summaryOutputFolder').value = savedSummaryFolder;
    }

    // Load persisted theme
    const savedTheme = localStorage.getItem('cenario_theme');
    if (savedTheme) {
        document.getElementById('themeSelect').value = savedTheme;
        changeTheme(savedTheme);
    }
</script>

</body>
</html>